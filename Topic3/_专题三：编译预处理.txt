一.编译过程简介：
    1.hello.c --预处理器--> hello.i --编译器--> hello.s --汇编器--> hello.o+libc.a --链接器-->hello.out(linux上的可执行文件)
    2.编译时代码会经过预处理器、编译器、汇编器、链接器四个部件的四次操作。
        (1).预编译(预处理指令：gcc -E file.c -o hello.i)            
            处理所有的注释，以空格代替。
            将所有的#define删除，并且展开所有的宏定义。
            处理条件编译指令#if,#ifdef,#elif,#else,#endif
            处理#include,展开被包含的文件
            保留编译器需要使用的#pragma指令(在后续的专题三-五中会进行相对的详细的讲解)
        (2).编译(编译指令：gcc -S file.c -o hello.s)
            对预处理文件进行一系列词法分析，语法分析，和语义分析.
                词法分析主要是分析关键字，标识符，立即数等是否合法。
                语法分析主要是分析表达式是否遵循语法规则。
                语义分析在语法分析上进一步分析表达式是否合法。
            分析结束后进行代码优化生成相应的汇编代码文件。
        (3).汇编(汇编指令：gcc -c file.s -o hello.o)
            将汇编代码文件转换为机器码。
        (4).链接
            将目标文件与库文件链接在一起，然后按照平台可执行文件格式，生成一个可执行文件。
            (此处的动态链接与静态链接之分就不做总结了)
    3.在出现一些奇怪错误时可以用单步纠错法（先看代码预处理的文件（.i文件），再看编译器编译后的（.s文件），一步步的看是哪出了问题）。


二.宏定义使用与分析：
    1.#define就是将预先设定好的代码块直接替代过去。
    2.#define可以比函数更强大。
    3.#define表达式比函数更容易出错。
    4.为了避免错误，宏定义的参数尽量不出现表达式。
    5.函数有一些弊端：会将数组参数退化为一个指针，
      所占用的空间大小也会变成一个指针占用的空间大小，而不是数组的空间大小。
    6.宏表达式与函数的对比：
        宏表达式在预编译期被处理，编译器不知道宏表达式的存在。
        宏表达式用"实参"完全代替形参，不进行任何运算。
        宏表达式不是被调用，而是记录一种形式，然后直接替代。
        因为不是被调用而是直接替换，所以不能出现递归定义。
    7.#define可以在任意处定义作用于整个程序，要想要使其作用域缩小可以使用#undef
      (#undef的作用就是取消#define)
    8.一些强大的内置宏：
        __FILE__ :被编译的文件名
        __LINE__ :当前房号
        __DATE__ :编译时的日期
        __TIME__ :编译时的时间
        __STDC__ :编译器是否遵循标准C规范
    有关内置宏的实际应用可以参考2-1-1.c文件的实例
    

三.条件编译使用分析：
    1.条件编译是预编译指示命令，用于控制是否编译某段代码。
      (#if...#else...#endif)
    2.条件编译的行为类似于C语言中的if..else。
        #include <stdio.h>
        #define C 1
        int main()
        {
            #if( C == 1 )
                printf("This is first printf...\n");
            #else
                printf("This is second printf...\n");
            #endif
            
            return 0;
        }
    3.条件编译与if..else语句的区别：
        if..else语句在预处理阶段是不做处理的，
        而条件编译经过预处理阶段就只剩下对应部分的代码块。
    4.#include的本质是将已经存在的文件内容嵌入到当前文件中，会递归的把文件中的文件继续展开.
        为了防止重复打开同一个文件会使用到#ifndef..#endif的组合，#ifndef的意思是：如果没有就定义。是if not define的简称。
    5.常见的条件编译指令：
        #if         如果条件为真，则执行相应的操作。
        #elif       如果前面条件为假，而该条件为真，则执行相应的操作。
        #else       如果前面的条件均为假，则执行相应操作。
        #endif      结束相应的条件编译指令
        #ifdef      如果该宏已定义，则执行相应的操作。
        #ifndef     如果该宏没有定义，则执行相应的操作。
    6.想在不修改文件的情况在编译时加上宏定义可用-D选项
      指令：gcc -D(直接写上想添加的宏) (文件名)
      例子：gcc -DC = 1 hello.c     (其中C = 1就是添加的宏)
    7.在实际做项目时为了区分不同的版本会经常用到6中说到的方式。
        实际操作：在编译时添加不同的宏，再用#ifdef...#else...#endif语句检测区分使用不同代码段，实现区分不同版本。


四.#error和#line：
    1.#error和#warning的基本含义。
        #error    用于生成一个编译错误信息，并停止编译。
            用法：#error message
        #warning  用于生成一个编译警告信息，但不会停止编译。
            用法：#warning message
    2.根据实际上的需要程序员可以利用#error和#warning来自己编写一些错误警告系统。
      来引导用户正确使用程序。
    3.在终端上的字符串写法:/"zifuchuan/".  
    4.#line的基本含义：
        #line     用于强制指定新的行号和编译文件名，并对源程序的代码重新编号。
            用法：#line number filename(filename可以省略)
            #line编译指示字本质是重定义__LINE__和__FILE__。


五.#pragma指令：
    1.#pragma是编译器指示字，用于指示编译器完成一些特定的动作。
        一般用法：#pragma paramater
    2.#pragma所定义的很多指示字是编译器和操作系统特有的。
    3.#pragma在不同的编译器间是不可移植的。
        预处理器将忽略它不认识的#pragma指令
        两个不同的编译器可能以两种不同的方式解释同一条#pragma指令
    4.message参数在大多数的编译器中都有相似的实现。
      在编译时输出消息到编译输出窗口中（就像#erorr和#warning一样）
    5.#pragma pack 可以改变编译器的默认对齐方式(默认是4字节对齐)
        (1).什么是内存对齐？
            不同类型的数据在内存中按照一定的规则排列；而不是顺序的一个接一个的排放，这就是对齐。
        (2).为什么需要内存对齐？
            cpu对内存的读取不是连续的，而是分成块读取的，块的大小只能是1，2，4，8，16字节。
            一次读取只能是一种大小的块所以要内存对齐一次性读取
        (3).struct占用的内存大小 
            第一各成员起始于0偏移处
            每个成员按其类型大小和指定对齐参数n中较小的一个进行对齐
                偏移地址和成员占用大小均需对齐
                结构体成员的对齐参数为其所有成员使用的对齐参数的最大值 
            结构体的总长度必须是所有对齐参数的整数倍
    有关struct内存大小计算可以参考5-2.c程序的实例来辅助理解，如果还是不理解可以专题五-5-44：33开始看有原版的讲解。


六.#和##运算符使用解析：
    1.#运算符用于在预编译期将宏参数转化为字符串。
        用处：打印变量名、函数名、数组名等各种东西只要加上一个#就可以转换成一个字符串。
    3.##运算符用于在预编译期粘连两个符号（常用于变量名的粘连）
    有关##的实际妙用可以参考6-2.c的一个实例（巧妙地将typedef给宏了）
